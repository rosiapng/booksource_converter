<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Deobfuscator</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@babel/parser@7.21.4/lib/index.umd.js"></script>
    <script src="https://unpkg.com/@babel/traverse@7.21.4/lib/index.umd.js"></script>
    <script src="https://unpkg.com/@babel/generator@7.21.4/lib/index.umd.js"></script>
</head>
<body>
    <h2>JavaScript Deobfuscator</h2>
    <textarea id="inputCode" rows="10" cols="50" placeholder="Paste obfuscated JavaScript here"></textarea>
    <br>
    <button onclick="deobfuscate()">Deobfuscate</button>
    <h3>Deobfuscated Code:</h3>
    <pre id="outputCode"></pre>

    <script>
        function deobfuscate() {
            const inputCode = document.getElementById("inputCode").value;

            try {
                // Parse JavaScript into AST
                const ast = window.babelParser.parse(inputCode, {
                    sourceType: "module", // Allow ES6 syntax
                    plugins: ["jsx"] // Enable JSX if needed
                });

                // Step 1: Remove Dead Code
                window.babelTraverse.default(ast, {
                    VariableDeclarator(path) {
                        const binding = path.scope.getBinding(path.node.id.name);
                        if (binding && binding.references === 0) {
                            path.remove();
                        }
                    },
                    IfStatement(path) {
                        if (path.node.test.type === "BooleanLiteral" && !path.node.test.value) {
                            path.remove();
                        }
                    },
                    ExpressionStatement(path) {
                        if (path.node.expression.type === "NumericLiteral" || path.node.expression.type === "StringLiteral") {
                            path.remove();
                        }
                    },
                    ReturnStatement(path) {
                        let next = path.getSibling(path.key + 1);
                        while (next.node) {
                            next.remove();
                            next = path.getSibling(next.key + 1);
                        }
                    }
                });

                // Step 2: Decode Obfuscation
                window.babelTraverse.default(ast, {
                    Identifier(path) {
                        const nameMap = { a: "username", b: "password", c: "token" };
                        if (nameMap[path.node.name]) {
                            path.node.name = nameMap[path.node.name];
                        }
                    },
                    StringLiteral(path) {
                        path.node.value = path.node.value.replace(/\\x([0-9A-Fa-f]{2})/g, (_, hex) => 
                            String.fromCharCode(parseInt(hex, 16))
                        );
                    },
                    CallExpression(path) {
                        if (path.node.callee.type === "FunctionExpression") {
                            path.replaceWithMultiple(path.node.callee.body.body);
                        }
                    }
                });

                // Step 3: Generate Clean Code
                const output = window.babelGenerator.default(ast, {
                    retainLines: true
                }).code;

                document.getElementById("outputCode").textContent = output;
            } catch (err) {
                document.getElementById("outputCode").textContent = "Error: " + err.message;
            }
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Deobfuscator</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@babel/parser"></script>
    <script src="https://unpkg.com/@babel/traverse"></script>
    <script src="https://unpkg.com/@babel/generator"></script>
</head>
<body>
    <h2>JavaScript Deobfuscator</h2>
    <textarea id="inputCode" rows="10" cols="50" placeholder="Paste obfuscated JavaScript here"></textarea>
    <br>
    <button onclick="deobfuscate()">Deobfuscate</button>
    <h3>Deobfuscated Code:</h3>
    <pre id="outputCode"></pre>

    <script>
        function deobfuscate() {
            const inputCode = document.getElementById("inputCode").value;

            try {
                // Parse code to AST
                const ast = Babel.parse(inputCode);

                // Step 1: Remove Dead Code
                Babel.traverse(ast, {
                    VariableDeclarator(path) {
                        // Remove unused variables
                        const binding = path.scope.getBinding(path.node.id.name);
                        if (binding && binding.references === 0) {
                            path.remove();
                        }
                    },
                    IfStatement(path) {
                        // Remove `if (false)` blocks
                        if (path.node.test.type === "BooleanLiteral" && !path.node.test.value) {
                            path.remove();
                        }
                    },
                    ExpressionStatement(path) {
                        // Remove unnecessary expressions like `"test";`
                        if (path.node.expression.type === "NumericLiteral" || path.node.expression.type === "StringLiteral") {
                            path.remove();
                        }
                    },
                    ReturnStatement(path) {
                        // Remove unreachable code after return
                        let next = path.getSibling(path.key + 1);
                        while (next.node) {
                            next.remove();
                            next = path.getSibling(next.key + 1);
                        }
                    }
                });

                // Step 2: Revert Obfuscation
                Babel.traverse(ast, {
                    Identifier(path) {
                        // Example: Rename variables back if possible
                        const nameMap = { a: "username", b: "password", c: "token" };
                        if (nameMap[path.node.name]) {
                            path.node.name = nameMap[path.node.name];
                        }
                    },
                    StringLiteral(path) {
                        // Decode hex-encoded strings like "\x68\x65\x6c\x6c\x6f" => "hello"
                        const decoded = path.node.value.replace(/\\x([0-9A-Fa-f]{2})/g, (match, hex) =>
                            String.fromCharCode(parseInt(hex, 16))
                        );
                        path.node.value = decoded;
                    },
                    CallExpression(path) {
                        // Unwrap self-executing functions
                        if (path.node.callee.type === "FunctionExpression") {
                            path.replaceWithMultiple(path.node.callee.body.body);
                        }
                    }
                });

                // Step 3: Generate Readable Code
                const output = Babel.transformFromAstSync(ast, inputCode, { 
                    presets: ['env'],
                    retainLines: true 
                }).code;

                document.getElementById("outputCode").textContent = output;
            } catch (err) {
                document.getElementById("outputCode").textContent = "Error: " + err.message;
            }
        }
    </script>
</body>
</html>